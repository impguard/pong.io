#!/bin/bash

function version.latest {
  local prev_version

  prev_version=$(git tag | grep -E "v_\\.*" | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4 | tail -1 | cut -d _ -f 2)

  echo "$prev_version"
}


function version.next {
  local prev_versions prev_version prev_major_version prev_minor_version minor_version

  prev_versions=$(git tag | grep -E "v_\\.*" | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4 | cut -d _ -f 2)

  if [ -z "$prev_versions" ]; then
    prev_version=0.0.0
  else
    prev_version=$(echo "$prev_versions" | tail -n 1)
  fi

  prev_major_version=$(echo "$prev_version" | cut -d . -f 1)
  prev_minor_version=$(echo "$prev_version" | cut -d . -f 2)

  minor_version=$((prev_minor_version + 1))

  echo "$prev_major_version.$minor_version.0"
}


bake_task build "Builds the game in development mode."
function build {
  local env node_env

  env=${1:-dev}
  if [ "$env" == "dev" ]; then
    node_env='development'
  else
    node_env='production'
  fi

  docker build \
    --build-arg NODE_ENV="$node_env" \
    -f 'build/Dockerfile' \
    -t 'pong:latest' .
  bake_echo_green 'Built the server container!'

  docker run --rm \
    -v "$PWD/dist/client:/game/dist/client" \
    'pong:latest' yarn build:client
  bake_echo_green "Built client files!"
}


bake_task build:prod "Builds the game in production mode."
function build:prod {
  build prod
}

bake_task compose "Runs docker compose."
function compose {
  docker-compose -f 'build/docker-compose.yml' "$@"
}


bake_task exec "Execs into the game server."
function exec {
  compose run server "$@"
}


bake_task yarn "Runs yarn in the container."
function yarn {
  docker-compose -f 'build/docker-compose.live.yml' run server yarn "$@"
}


bake_task run "Runs the game."
function run {
  compose up
}


bake_task run:live "Runs the game with live reloading."
function run:live {
  local id

  if [ ! -d node_modules ]; then
    bake_echo_yellow 'Caching node modules...'

    id=$(docker create --rm --name 'pong-cache' 'pong:latest' true)
    docker cp "$id:/game/node_modules" ./node_modules
    docker rm "$id" 1>/dev/null

    bake_echo_green "Cache completed. Run 'bake yarn' to update."
  fi

  docker-compose -f 'build/docker-compose.live.yml' up
}


bake_task push "Pushes the development build."
function push {
  local env version

  git fetch --tags

  version=${1:-$(version.next)}
  env=${2:-dev}

  bake_echo_yellow "Building $version"
  build "$env"

  bake_echo_yellow "Pushing client files to s3"
  aws s3 sync "./dist/client/" "s3://pong-client-builds/$env/$version" --delete

  bake_echo_yellow "Pushing server image to ecr"
  local image_id="344778228378.dkr.ecr.us-west-2.amazonaws.com/pong:$env-$version"
  docker tag pong:latest "$image_id"
  docker push "$image_id"
}


bake_task push:prod "Pushes the production build."
function push:prod {
  local version
  version=${1:-$(version.next)}

  git tag -a "v_$version" -m "$version"
  git push --tags

  push "$version" prod
}


bake_task deploy "Deploys a build to an environment."
function deploy {
  local build_env version env

  if [ "$#" -lt 1 ]; then
    bake_echo_red "usage: bake deploy ENV [BUILD_ENV] [VERSION]"
    exit 1
  fi

  env=$1
  build_env=${2:-dev}

  if [ "$build_env" == 'dev' ]; then
    version=${3:-$(version.next)}
  else
    version=${3:-$(version.latest)}
  fi

  local builds_bucket deploy_bucket image_id

  builds_bucket="s3://pong-client-builds/$build_env/$version"
  deploy_bucket="s3://pong-$env-site"
  image_id="344778228378.dkr.ecr.us-west-2.amazonaws.com/pong:$build_env-$version"

  if ! aws s3 ls "$builds_bucket" >/dev/null; then
    bake_echo_red "$builds_bucket does not exist in S3"
    exit 1
  fi

  if ! aws ecr list-images --registry-id 344778228378 --repository-name pong | grep "$build_env-$version" >/dev/null; then
    bake_echo_red "$image_id does not exist in ECR"
    exit 1
  fi

  bake_echo_yellow "Deploying $build_env-$version build to client $env"
  aws s3 sync "$builds_bucket" "$deploy_bucket" --delete

  bake_echo_yellow "Deploying $build_env-$version build to server $env"

  local taskdef task
  taskdef=$(jq ". | .containerDefinitions[0].image = \"$image_id\" | ." deploy/task-definition.json)
  task=$(aws ecs register-task-definition --family "pong-$env-server" --cli-input-json "$taskdef")

  echo "$task" | jq -r '.taskDefinition.taskDefinitionArn'
}


bake_task server:start "Starts a game server."
function server:start {
  local taskdefarn taskrun

  taskdefarn=$1
  taskrun=$(jq ". | .taskDefinition = \"$taskdefarn\" | ." deploy/task-run.json)

  aws ecs run-task --cli-input-json "$taskrun" \
    | jq -r ".tasks[].taskArn"
}


bake_task server:stop "Stops a game server."
function server:stop {
  aws ecs stop-task --cluster "pong-sandbox" --task "$1" >/dev/null
  bake_echo_green "Server stopped!"
}


bake_task server:ls "Lists all running game servers."
function server:ls {
  local arns
  arns=$(aws ecs list-tasks --cluster "pong-sandbox" | jq -r '.taskArns | join(" ")')

  # shellcheck disable=SC2086
  aws ecs describe-tasks --cluster "pong-sandbox" --tasks $arns \
    | jq '.tasks[] | { "arn": .taskArn, "status": .lastStatus }'
}

bake_task server:ip "Shows ip for running game server task."
function server:ip {
  local taskdefarn eni

  taskdefarn=$1

  description=$(aws ecs describe-tasks --cluster "pong-sandbox" --tasks "$taskdefarn")
  eni=$(echo "$description" | jq -r '.tasks[].attachments[0].details[] | select(.name == "networkInterfaceId") | .value')
  aws ec2 describe-network-interfaces --network-interface-ids "$eni" \
    | jq -r '.NetworkInterfaces[].Association.PublicIp'
}
